
#include <iostream>
#include <queue>
#include <stack>
using namespace std;

// 왼쪽으로 한 칸 이동시킨다. a1, ..., ak가 a2, ..., ak, a1이 된다.
int seq_left(queue<int> q, int n) {
    int cnt = 0;
    while (q.front() != n) {
        q.push(q.front());
        q.pop();
        cnt++;
    }
    return cnt;
}

// 오른쪽으로 한 칸 이동시킨다. a1, ..., ak가 ak, a1, ..., ak-1이 된다.
int seq_right(queue<int> q, int n) {
    stack<int> s;
    int cnt = 0;
    while (!q.empty()) {  // 스택에 큐의 앞부분부터 넣어준다.
        s.push(q.front());
        q.pop();
    }

    while (s.top() != n) {  // 스택의 윗부분부터 삭제하며 카운트 증가한다.
        s.pop();
        cnt++;
    }
    cnt++;  // 스택의 top이 n이 될때의 카운트를 증가시켜준다.
    return cnt;
}

int main() {
    // 덱을 구현하기.
    int n, m, x, cnt = 0, left, right, size;
    queue<int> deque;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        deque.push(i);  // 1~n으로 이루어진 덱 만들기
    }
    for (int i = 0; i < m; i++) {  // m개의 위치를 찾기
        cin >> x;

        left = seq_left(deque, x);           // 왼쪽으로 돌았을 때 개수
        right = seq_right(deque, x);         // 오른쪽으로 돌았을 때 개수
        size = left < right ? left : right;  // 크면 right 작으면 left를 저장
        cnt += size;                         // 해당 개수만큼 카운트 증가

        while (1) {  // 해당 x 큐에서 제거
            if (deque.front() == x) {
                deque.pop();
                break;
            }
            deque.push(deque.front());
            deque.pop();
        }
    }
    cout << cnt;
}
